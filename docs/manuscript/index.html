<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BioNumPy manuscript &mdash; bionumpy  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/design-tabs.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Implementing encodings" href="../developer_guide/encodings.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../menu.html" class="icon icon-home"> bionumpy
          </a>
              <div class="version">
                0.2.11
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Home</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Geting started with BioNumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">A 10-minute introduction to BioNumPy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/fastq_filtering.html">Filtering FASTQ reads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/bam_handling.html">Working with BAM-files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/subsetting_bed.html">Getting read pileup for multiple regions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/fastqc.html">FastQC-like quality-checking of FASTQ files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/gc_content.html">Computing GC content inside genes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/numpy_operations.html">Using NumPy functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/position_weight_matrix.html">Position Weight Matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/set_of_sequences.html">Simulating sequence datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/similarity_measures.html">Computing the similarity between two BED-files</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">BioNumPy Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../source/reading_files.html">Reading files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/working_with_big_data.html">Working with big data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/encoding.html">Encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/supported_file_formats.html">Supported file formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/supported_file_formats.html#implementing-a-new-file-format">Implementing a new file format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/sequences.html">Sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/intervals.html">Intervals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/multiple_data_sources.html">Working with Multiple Files/Data Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/broadcastable_functions.html">Broadcastable Functions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules/bnpdataclass.html">BnpDataclass</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/genome_arithmetics.html">Genome arithmetics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/io.html">IO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/sequences.html">Sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/streams.html">Streams</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../developer_guide.html">Developer guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">BioNumPy manuscript</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#abstract">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#results">Results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-bionumpy-library">The BioNumPy Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="#benchmarks">Benchmarks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-usage">Example usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example-1-using-bionumpy-on-sequence-data">Example 1: Using BioNumPy on sequence data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-2-analysing-motif-matches-inside-transcription-factor-peaks">Example 2: Analysing motif matches inside transcription factor peaks</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#implementation-details">Implementation details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-representation">Data representation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#development">Development</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#discussion">Discussion</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../menu.html">bionumpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../menu.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">BioNumPy manuscript</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/manuscript/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="bionumpy-manuscript">
<h1>BioNumPy manuscript<a class="headerlink" href="#bionumpy-manuscript" title="Permalink to this headline"></a></h1>
<p>Knut Rand <a class="footnote-reference brackets" href="#id2" id="id1">1</a>, Ivar Grytten, Milena Pavlovic, Chakravarthi Kanduri and Geir Kjetil Sandve</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Correspondence: <a class="reference external" href="mailto:knutdr&#37;&#52;&#48;ifi&#46;uio&#46;no">knutdr<span>&#64;</span>ifi<span>&#46;</span>uio<span>&#46;</span>no</a></p>
</dd>
</dl>
<section id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline"></a></h2>
<p>Python is a popular and widespread programming language for scientific computing, in large part due to the powerful <em>array programming</em> library NumPy, which makes it easy to write clean, vectorized and efficient code for handling large datasets. A challenge with using array programming for biological data is that the data is often non-numeric and variable-length (such as DNA sequences), inhibiting out-of-the-box use of standard array programming techniques. Thus, a tradition in bioinformatics has been to use low-level languages like C and C++ to write efficient code. This makes the tools less transparent to the average computational biologist - making them harder to understand, modify and contribute to.</p>
<p>We here present a new Python package BioNumPy, which adds a layer on top of NumPy in order to enable intuitive array programming on biological datasets. BioNumPy is able to efficiently load biological datasets (e.g. FASTQ-files, BED-files and BAM-files) into NumPy-like data structures, so that NumPy operations like indexing, vectorized functions and reductions can be applied to the data. We show that BioNumPy is considerably faster than vanilla Python and other Python packages for common bioinformatics tasks, and in many cases as fast as tools written in C/C++. BioNumPy thus bridges a long-lasting gap in bioinformatics, allowing the same programming language (Python) to be used across the full spectrum from quick and simple scripts to computationally efficient processing of large-scale data.</p>
</section>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h2>
<p>Python is one of the most commonly used and fastest growing programming languages <span id="id3">[<a class="reference internal" href="#id38" title="Tiobe index. Jun 2022. URL: https://www.tiobe.com/tiobe-index/.">1</a>]</span>. Being a high-level language, Python is flexible and suits a wide variety of analyses. It is both easy to learn for biologists new to programming and a powerful language for experienced bioinformaticians. However, a common hurdle is that vanilla Python is too slow to be a viable option for large-scale analyses. Thus, bioinformaticians often end up using non-transparent and error-prone one-liners on the unix command line, or end up developing and using tools written in low-level languages such as C and C++.</p>
<p>In other scientific fields (e.g. physics, engineering and machine learning), Python is being extensively and successfully used for high-performance computing and large-scale analysis <span id="id4">[<a class="reference internal" href="#id33" title="Paszke, Adam and Gross, Sam and Massa, Francisco and Lerer, Adam and Bradbury, James and Chanan, Gregory and Killeen, Trevor and Lin, Zeming and Gimelshein, Natalia and Antiga, Luca and Desmaison, Alban and Kopf, Andreas and Yang, Edward and DeVito, Zachary and Raison, Martin and Tejani, Alykhan and Chilamkurthy, Sasank and Steiner, Benoit and Fang, Lu and Bai, Junjie and Chintala, Soumith. PyTorch: An Imperative Style, High-Performance Deep Learning Library. 2019. URL: http://papers.neurips.cc/paper/9015-pytorch-an-imperative-style-high-performance-deep-learning-library.pdf.">2</a>, <a class="reference internal" href="#id34" title="Ryan Abernathey and Kevin Paul and Joe Hamman and Matthew Rocklin and Chiara Lepore and Michael Tippett and Naomi Henderson and Richard Seager and Ryan May and Davide Del Vento. Pangeo NSF Earthcube Proposal. 8 2017. URL: https://figshare.com/articles/Pangeo_NSF_Earthcube_Proposal/5361094, doi:10.6084/m9.figshare.5361094.v1.">3</a>, <a class="reference internal" href="#id35" title="Martin Raspaud and David Hoese and Panu Lahtinen and Gerrit Holl and Stephan Finkensieper and Simon Proud and Adam Dybbroe and Andrea Meraner and Joleen Feltz and Xin Zhang and strandgren and Sauli Joro and William Roberts and BENR0 and Lars Orum Rasmussen and mherbertson and Jorge Humberto Bravo MÃ©ndez and Yufei Zhu and rdaruwala and Pierre de Buyl and Tommy Jasmin and BengtRydberg and Christian Kliche and Talfan Barnie and Eysteinn SigurÃ°sson and Sebastian Brodehl and R.K.Garcia and Thomas Leppelt and Taiga Tsukada. Pytroll/satpy: version 0.38.0 (2022/11/11). November 2022. URL: https://doi.org/10.5281/zenodo.7313596, doi:10.5281/zenodo.7313596.">4</a>, <a class="reference internal" href="#id36" title="Robitaille, Thomas P and Tollerud, Erik J and Greenfield, Perry and Droettboom, Michael and Bray, Erik and Aldcroft, Tom and Davis, Matt and Ginsburg, Adam and Price-Whelan, Adrian M and Kerzendorf, Wolfgang E and others. Astropy: a community python package for astronomy. Astronomy &amp; Astrophysics, 558:A33, 2013.">5</a>]</span>. This is in large part thanks to the very powerful <em>array programming</em> package NumPy <span id="id5">[<a class="reference internal" href="#id37" title="Harris, Charles R and Millman, K Jarrod and Van Der Walt, Stéfan J and Gommers, Ralf and Virtanen, Pauli and Cournapeau, David and Wieser, Eric and Taylor, Julian and Berg, Sebastian and Smith, Nathaniel J and others. Array programming with NumPy. Nature, 585(7825):357–362, 2020.">6</a>]</span>, which enables memory-efficient representation and fast analysis of numeric data (similar to R and MATLAB). For problems that lend themself to the array programming paradigm, solutions based on suited libraries in high-level languages are usually easier to write, read, use and adapt than corresponding programs written in low-level languages like C and C++. However, the discrete and variable-length nature of biological sequence data inhibits the out-of-the-box use of standard array programming languages and libraries. Due to a lack of suited high-performance libraries in Python, two distinct implementation strategies have come to dominate the processing and analysis of biosequence data: a) the use of high-level languages like Python with libraries like BioPython <span id="id6">[<a class="reference internal" href="#id40" title="Cock, Peter JA and Antao, Tiago and Chang, Jeffrey T and Chapman, Brad A and Cox, Cymon J and Dalke, Andrew and Friedberg, Iddo and Hamelryck, Thomas and Kauff, Frank and Wilczynski, Bartek and others. Biopython: freely available Python tools for computational molecular biology and bioinformatics. Bioinformatics, 25(11):1422–1423, 2009.">7</a>]</span> and Biotite <span id="id7">[<a class="reference internal" href="#id39" title="Kunzmann, Patrick and Hamacher, Kay. Biotite: a unifying open source computational biology framework in Python. BMC bioinformatics, 19(1):1–8, 2018.">8</a>]</span> for smaller-scale analytical exploration in individual life science investigations, and b) the use of low-level languages like C to create command-line executables for common compute-intensive tasks.</p>
<p>We here present the BioNumPy package, which enables efficient and intuitive array programming on biological data in Python. BioNumPy supports a broad range of bioinformatics analyses, with the main philosophy being that data structures should behave  as closely as possible to standard numeric NumPy arrays. This means that BioNumPy is easy to learn for users familiar with NumPy or with array programming languages like R and Matlab. BioNumPy is open source and freely available at <a class="reference external" href="https://github.com/bionumpy/bionumpy/">https://github.com/bionumpy/bionumpy/</a>, and can be installed through the Python package manager Pip. BioNumPy comes with extensive documentation and a user guide that makes it easy to use for a wide range of bioinformatics problems.</p>
</section>
<section id="results">
<h2>Results<a class="headerlink" href="#results" title="Permalink to this headline"></a></h2>
<section id="the-bionumpy-library">
<h3>The BioNumPy Library<a class="headerlink" href="#the-bionumpy-library" title="Permalink to this headline"></a></h3>
<p>BioNumPy is a Python package for efficiently reading, representing and analysing biological datasets. All time-critical operations are implemented in NumPy, meaning that BioNumPy performs comparably to customised low-level language implementations. The key features of BioNumPy are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Reading/writing biological datasets directly to/from NumPy-like data structures, providing easy access to the data through an intuitive and easy-to-use API.</p></li>
<li><p>Processing and analysing such biological data efficiently using a NumPy-like interface.</p></li>
</ol>
</div></blockquote>
<p>As an example, reading in a set of sequences from a FASTQ-file and computing their GC-content is as simple as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">bionumpy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;reads.fq.gz&quot;</span><span class="p">)</span>
<span class="n">gc_content</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">sequence</span> <span class="o">==</span> <span class="s2">&quot;G&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sequence</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>In the example above, the <cite>data.sequence</cite> object is a NumPy-like data structure containing all the sequences in our datasets. Common NumPy operations, like indexing and vectorized operations, work with this data structure. BioNumPy also supports broadcasting of functions along one and two-dimensional arrays (in the same way as NumPy), allowing to e.g. easily compute GC content per sequence, or per position across all sequences. This makes BioNumPy powerful and flexible, allowing it to perform a wide range of operations on biological datasets.</p>
<p>BioNumPy comes with extensive documentation, available at <a class="reference external" href="https://bionumpy.github.io/bionumpy">https://bionumpy.github.io/bionumpy</a>, showing how to do common tasks for a wide range of data formats and domains.</p>
</section>
<section id="benchmarks">
<h3>Benchmarks<a class="headerlink" href="#benchmarks" title="Permalink to this headline"></a></h3>
<p>We compare the speed of BioNumPy against other existing Python packages and commonly used non-Python tools on a set of typical bioinformatics tasks. As seen in Figure 1, we find that BioNumPy is generally considerably faster than vanilla Python solutions, including the commonly used Python packages BioPython and Biotite, which mostly rely on Python for-loops to perform operations on datasets. On problems where designated efficient bioinformatics tools are commonly used (intersection of BED-files, kmer counting and VCF operations), we find that BioNumPy is close to, or as efficient as, tools written in C/C++ (BEDTools <span id="id8">[<a class="reference internal" href="#id32" title="Quinlan, Aaron R and Hall, Ira M. BEDTools: a flexible suite of utilities for comparing genomic features. Bioinformatics, 26(6):841–842, 2010.">9</a>]</span>, Jellyfish <span id="id9">[<a class="reference internal" href="#id31" title="Marcais, G and Kingsford, C. Jellyfish: A fast k-mer counter. Tutorialis e Manuais, 1:1–8, 2012.">10</a>]</span> and BCFTools <span id="id10">[<a class="reference internal" href="#id30" title="Danecek, Petr and Bonfield, James K and Liddle, Jennifer and Marshall, John and Ohan, Valeriu and Pollard, Martin O and Whitwham, Andrew and Keane, Thomas and McCarthy, Shane A and Davies, Robert M and others. Twelve years of SAMtools and BCFtools. Gigascience, 10(2):giab008, 2021.">11</a>]</span>). While these benchmarks only cover a very small subset of operations, and we only compare against a small subset of available tools, we believe the results still illustrate that BioNumPy can achieve the same performance as dedicated tools written in low-level languages. A Snakemake pipeline for reproducing the results can be found at <a class="reference external" href="https://github.com/bionumpy/bionumpy/tree/master/benchmarks">https://github.com/bionumpy/bionumpy/tree/master/benchmarks</a>, along with an open invitation to expand the benchmark with additional tools and cases.</p>
<figure class="align-default" id="id42">
<a class="reference internal image-reference" href="../_images/report_big.png"><img alt="../_images/report_big.png" src="../_images/report_big.png" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-text"><strong>Benchmarking BioNumPy against other tools and methods on various typical bioinformatics tasks.</strong></span><a class="headerlink" href="#id42" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="example-usage">
<h3>Example usage<a class="headerlink" href="#example-usage" title="Permalink to this headline"></a></h3>
<p>We here show two examples to illustrate how BioNumPy can be used.</p>
<section id="example-1-using-bionumpy-on-sequence-data">
<h4>Example 1: Using BioNumPy on sequence data<a class="headerlink" href="#example-1-using-bionumpy-on-sequence-data" title="Permalink to this headline"></a></h4>
<p>In the following example, we represent a few sequences with BioNumPy and show how basic NumPy functionality works:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">bionumpy</span> <span class="k">as</span> <span class="nn">bnp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Normally, you will read sequences from file using bnp.open</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># but for testing, the bnp.as_encoded_array function is useful</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sequences</span> <span class="o">=</span> <span class="n">bnp</span><span class="o">.</span><span class="n">as_encoded_array</span><span class="p">([</span><span class="s2">&quot;ACTGA&quot;</span><span class="p">,</span> <span class="s2">&quot;AACCA&quot;</span><span class="p">,</span> <span class="s2">&quot;GA&quot;</span><span class="p">,</span> <span class="s2">&quot;AATTTT&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We remove the first base</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sequences</span> <span class="o">=</span> <span class="n">sequences</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span>
<span class="go">CTGA</span>
<span class="go">ACCA</span>
<span class="go">A</span>
<span class="go">ATTTT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Creating a mask is easy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_A</span> <span class="o">=</span> <span class="n">sequences</span> <span class="o">==</span> <span class="s2">&quot;A&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">is_A</span><span class="p">)</span>
<span class="go">[False False False  True]</span>
<span class="go">[ True False False  True]</span>
<span class="go">[ True]</span>
<span class="go">[ True False False False False]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Counting As per sequence using axis=1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">is_A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 2, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Counting ratio of As per base position using np.mean with axis=0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">is_A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0.75      , 0.        , 0.        , 0.66666667, 0.        ])</span>
</pre></div>
</div>
</section>
<section id="example-2-analysing-motif-matches-inside-transcription-factor-peaks">
<h4>Example 2: Analysing motif matches inside transcription factor peaks<a class="headerlink" href="#example-2-analysing-motif-matches-inside-transcription-factor-peaks" title="Permalink to this headline"></a></h4>
<p>In the following example, we show how BioNumPy can be used to easily combine different types of datasets. We read transcription factor peaks from a bed file, fetch the peak sequences from an indexed reference genome and analyse motif scores within the peaks using data from the Jaspar database <span id="id11">[<a class="reference internal" href="#id25" title="Fornes, Oriol and Castro-Mondragon, Jaime A and Khan, Aziz and Van der Lee, Robin and Zhang, Xi and Richmond, Phillip A and Modi, Bhavi P and Correard, Solenne and Gheorghe, Marius and Baranašić, Damir and others. JASPAR 2020: update of the open-access database of transcription factor binding profiles. Nucleic Acids Research, 48(D1):D87–D92, 2020.">12</a>]</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bionumpy.sequence.position_weight_matrix</span> <span class="kn">import</span> <span class="n">PWM</span><span class="p">,</span> <span class="n">get_motif_scores</span>
<span class="kn">import</span> <span class="nn">bionumpy</span> <span class="k">as</span> <span class="nn">bnp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyjaspar</span> <span class="kn">import</span> <span class="n">jaspardb</span>
<span class="kn">import</span> <span class="nn">plotly.express</span> <span class="k">as</span> <span class="nn">plx</span>

<span class="c1"># Read peaks and reference genom</span>
<span class="n">peaks</span> <span class="o">=</span> <span class="n">bnp</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;ctcf.bed.gz&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">reference_genome</span> <span class="o">=</span> <span class="n">bnp</span><span class="o">.</span><span class="n">open_indexed</span><span class="p">(</span><span class="s2">&quot;hg38.fa&quot;</span><span class="p">)</span>

<span class="c1"># Change start and end position of peaks (100 bp around centre)</span>
<span class="n">midpoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">peaks</span><span class="o">.</span><span class="n">start</span><span class="o">+</span><span class="n">peaks</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
<span class="n">peaks</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">midpoints</span> <span class="o">-</span> <span class="mi">50</span>
<span class="n">peaks</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">midpoints</span> <span class="o">+</span> <span class="mi">50</span>

<span class="c1"># Fetch sequences within each peak</span>
<span class="n">peak_sequences</span> <span class="o">=</span> <span class="n">reference_genome</span><span class="o">.</span><span class="n">get_interval_sequences</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>

<span class="c1"># Fetch a motif from Jaspar and read it into BioNumPy</span>
<span class="n">jaspar_object</span> <span class="o">=</span> <span class="n">jaspardb</span><span class="p">(</span><span class="n">release</span><span class="o">=</span><span class="s2">&quot;JASPAR2020&quot;</span><span class="p">)</span>
<span class="n">ctcf_motif</span> <span class="o">=</span> <span class="n">jaspar_object</span><span class="o">.</span><span class="n">fetch_motifs_by_name</span><span class="p">(</span><span class="s1">&#39;CTCF&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">ctcf_pwm</span> <span class="o">=</span> <span class="n">PWM</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">ctcf_motif</span><span class="o">.</span><span class="n">pwm</span><span class="p">)</span>

<span class="c1"># Get motif scores and make a boolean mask of likely binding sites</span>
<span class="n">motif_scores</span> <span class="o">=</span> <span class="n">get_motif_scores</span><span class="p">(</span><span class="n">peak_sequences</span><span class="p">,</span> <span class="n">ctcf_pwm</span><span class="p">)</span>
<span class="n">has_motif_match</span> <span class="o">=</span> <span class="n">motif_scores</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># Plot mean matches per base (axis=0)</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plx</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">has_motif_match</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">template</span><span class="o">=</span><span class="s1">&#39;seaborn&#39;</span><span class="p">,</span>
               <span class="n">labels</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="s2">&quot;Position in peak&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="s2">&quot;Ratio of peaks with motif match&quot;</span><span class="p">},</span>
               <span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">write_image</span><span class="p">(</span><span class="s2">&quot;motif_matches.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-default" id="id43">
<a class="reference internal image-reference" href="../_images/motif_matches.png"><img alt="../_images/motif_matches.png" src="../_images/motif_matches.png" style="width: 60%;" /></a>
<figcaption>
<p><span class="caption-text"><strong>Plot generated in Example 2.</strong> Showing ratio of peaks with a motif match per base position, with an enrichment at the centre of each peak as one would expect.</span><a class="headerlink" href="#id43" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="implementation-details">
<h2>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline"></a></h2>
<section id="data-representation">
<h3>Data representation<a class="headerlink" href="#data-representation" title="Permalink to this headline"></a></h3>
<p>BioNumPy internally stores sequence data (e.g. nucleotides or amino acids) as numeric values, allowing the use of standard NumPy arrays for data representation and processing. A key way in which BioNumpy achieves high performance is by storing multiple data entries in shared NumPy arrays. To illustrate the benefit of this approach, consider the example where we want to count the number of Gs and Cs in a large set of DNA sequences. With existing Python packages like BioPython and Biotite, this must be done by iterating over the sequences using Python for-loops, which is slow when the number of sequences is large. BioNumPy, however, stores all sequences in only one or a few shared NumPy arrays (Figure 3a), meaning that vectorized NumPy operations can be used to do the counting in a fraction of the time.</p>
<p>Storing multiple elements in shared arrays is trivial if the elements all have the same size, since a matrix representation can be used. However, for biological data, it is common that data elements vary in size. For instance, sequences in FASTA files are rarely all of the exact same size. BioNumPy uses the RaggedArray data structure from the npstructures package (<a class="reference external" href="https://github.com/bionumpy/npstructures">https://github.com/bionumpy/npstructures</a>, developed in tandem with BioNumPy) to tackle this problem (Figure 2). The RaggedArray can be seen as a matrix where rows can have different lengths. The npstructures RaggedArray implementation is compatible with most common NumPy operations, like indexing (Figure 3b), vectorized operations (Figure 3c), and reductions (Figure 3d). As far as possible, objects in BioNumPy follow the array interoperability protocols defined by NumPy (<a class="reference external" href="https://numpy.org/doc/stable/user/basics.interoperability.html">https://numpy.org/doc/stable/user/basics.interoperability.html</a>)</p>
<figure class="align-default" id="id44">
<a class="reference internal image-reference" href="../_images/ragged_array_figure.png"><img alt="../_images/ragged_array_figure.png" src="../_images/ragged_array_figure.png" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-text"><strong>Overview of the RaggedArray and EncodedRaggedArray data structures</strong>. A RaggedArray is similar to a NumPy array/matrix but can represent a matrix consisting of rows with varying lengths (a). This makes it able to efficiently represent data with varying lengths in a shared data structure. A RaggedArray supports many of the same operations as NumPy arrays, such as indexing (b), vectorization (c) and reduction (d). An EncodedRaggedArray is a RaggedArray that supports storing and operating on non-numeric data (e.g. DNA-sequences) by encoding the data and keeping track of the encoding (e). An EncodedRaggedArray supports the same operations as RaggedArrays (f). This figure is an adopted and modified version of  Figure 1 in <span id="id12">[<a class="reference internal" href="#id37" title="Harris, Charles R and Millman, K Jarrod and Van Der Walt, Stéfan J and Gommers, Ralf and Virtanen, Pauli and Cournapeau, David and Wieser, Eric and Taylor, Julian and Berg, Sebastian and Smith, Nathaniel J and others. Array programming with NumPy. Nature, 585(7825):357–362, 2020.">6</a>]</span> and is licensed under a Creative Commons Attribution 4.0 International License (<a class="reference external" href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a>).</span><a class="headerlink" href="#id44" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="development">
<h3>Development<a class="headerlink" href="#development" title="Permalink to this headline"></a></h3>
<p>BioNumPy has been developed following the principles of continuous integration and distribution <span id="id13">[<a class="reference internal" href="#id29" title="Forsgren, Nicole and Smith, Dustin and Humble, Jez and Frazelle, Jessie. 2019 Accelerate state of devops report. 2019.">13</a>]</span>. The codebase is thoroughly and automatically tested through an extensive collection of unit tests, application tests, integrations tests and property-based tests <span id="id14">[<a class="reference internal" href="#id27" title="MacIver, David R and Hatfield-Dodds, Zac and others. Hypothesis: a new approach to property-based testing. Journal of Open Source Software, 4(43):1891, 2019.">14</a>]</span>. New code changes are automatically benchmarked and tested before being automatically published, ensuring that updates can be frequent, while high code quality is maintained. This makes it safe and easy to allow contributions from new contributors, which is important for longevity and community adoption of the package.</p>
</section>
</section>
<section id="discussion">
<h2>Discussion<a class="headerlink" href="#discussion" title="Permalink to this headline"></a></h2>
<p>We have presented a new Python package, BioNumPy, for efficient representation and analysis of biological datasets. We have shown that BioNumPy is usually considerably faster than both vanilla Python scripts and commonly used Python packages for performing similar tasks. BioNumPy also has comparable efficiency to commonly used efficient tools written in C/C++.</p>
<p>While BioNumPy is fast on basic operations such as kmer counting and getting reverse complements of reads, we want to emphasise that BioNumPy is not specifically designed for standard tasks where  tailored and highly optimised tools already exists <span id="id15">[<a class="reference internal" href="#id30" title="Danecek, Petr and Bonfield, James K and Liddle, Jennifer and Marshall, John and Ohan, Valeriu and Pollard, Martin O and Whitwham, Andrew and Keane, Thomas and McCarthy, Shane A and Davies, Robert M and others. Twelve years of SAMtools and BCFtools. Gigascience, 10(2):giab008, 2021.">11</a>]</span>. BioNumPy is instead meant to be used as a library inside Python, and is useful when one e.g. wants to perform multiple operations on a dataset, explore or play around with datasets, or perform analyses that integrate multiple datasets in novel ways. We also invite the community to develop a broad variety of functionality for dedicated purposes with BioNumPy as an internal workhorse.</p>
<p>As shown in Figure 1, BioNumPy is not always faster than vanilla Python code, e.g. for the case where one is only reading a FASTA file, subsampling the sequences and writing the results back to file. The reason is that although BioNumPy reads all data into NumPy-arrays that can be efficiently subsampled, BioNumPy performs operations beyond the vanilla Python implementation, such as validating, encoding and representing the data efficiently. These additional steps come handy when you want to do more operations on the data, such as combining it with other datasets or querying it in different ways. An example of a case where BioNumPy gives considerable speedup over native tools is the problem of computing the Jaccard similarity index between all pairs of a set of bed-files. Since BioNumPy can keep all files in memory, it is considerably faster than dedicated packages like BEDTools, which needs to read each bed-file from disk every time a pair of BED-files are to be compared.</p>
<p>Many common bioinformatics tasks are today typically performed as a series of bash commands, using a combination of sed, AWK, Grep, Perl and/or other native unix utility tools. As an example, consider the following bash-code for converting from FASTQ to FASTA:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>zcat file.fastq.gz <span class="p">|</span> paste - - - - <span class="p">|</span> perl -ane <span class="s1">&#39;print &quot;&gt;$F[0]\n$F[2]\n&quot;;&#39;</span> <span class="p">|</span> gzip -c &gt; file.fasta.gz
</pre></div>
</div>
<p>While such commands often yield fast results, there are in our opinion several drawbacks to this approach, which a package like BioNumPy addresses. First, bash commands are difficult to read and understand, which increases the chance for errors. Second, since such commands typically come in the form of ad-hoc scripts, these are usually not version controlled, not tested and thus not reproducible (each person typically has their own script). Third, it is inconvenient to write unit tests, defensive assertion code or do runtime inspection/debugging on such bash scripts, meaning that logical errors can easily go unnoticed. A better solution is thus to instead use specialised tools, such as e.g. seqtk or BioNumpy. The task of converting from FASTQ to FASTA can be done like this in BioNumPy:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">bnp</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;output.fasta&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_file</span><span class="p">:</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">bnp</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;input.fastq&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read_chunks</span><span class="p">())</span>
</pre></div>
</div>
<p>Since BioNumPy is flexible in its input, it works well with existing packages and solutions for fetching data from databases, e.g. in combination with the various BioPython modules for downloading data from databases like Encode <span id="id16">[<a class="reference internal" href="#id24" title="de Souza, Natalie. The ENCODE project. Nature Methods, 9(11):1046–1046, 2012.">15</a>]</span> and Jaspar <span id="id17">[<a class="reference internal" href="#id25" title="Fornes, Oriol and Castro-Mondragon, Jaime A and Khan, Aziz and Van der Lee, Robin and Zhang, Xi and Richmond, Phillip A and Modi, Bhavi P and Correard, Solenne and Gheorghe, Marius and Baranašić, Damir and others. JASPAR 2020: update of the open-access database of transcription factor binding profiles. Nucleic Acids Research, 48(D1):D87–D92, 2020.">12</a>]</span>. This ease of interoperability is also the reason why we have limited the scope of BioNumPy to not including modules for e.g. fetching data from online databases.</p>
<p>It can be speculated that the difficulty of writing efficient code for large-scale analyses in Python is an important reason why a lot of central bioinformatics tools are instead written in low-level and harder to learn languages like C or C++  <span id="id18">[<a class="reference internal" href="#id32" title="Quinlan, Aaron R and Hall, Ira M. BEDTools: a flexible suite of utilities for comparing genomic features. Bioinformatics, 26(6):841–842, 2010.">9</a>, <a class="reference internal" href="#id30" title="Danecek, Petr and Bonfield, James K and Liddle, Jennifer and Marshall, John and Ohan, Valeriu and Pollard, Martin O and Whitwham, Andrew and Keane, Thomas and McCarthy, Shane A and Davies, Robert M and others. Twelve years of SAMtools and BCFtools. Gigascience, 10(2):giab008, 2021.">11</a>]</span>. The fact that tools are written in such languages means that the large majority of bioinformaticians and computational biologists - who are typically only familiar with bash, R, and/or Python - are not able to easily contribute to the development of tools or understand/learn the internal workings of the methods they use. This limits transparency of bioinformatics research, and is also a broader problem since the continually growing size of biological data necessitates fast and efficient tools and libraries. Our hope is that BioNumPy is able to bridge this gap by making it possible for anyone to more easily work with large biological datasets in Python.</p>
<p><strong>Funding</strong></p>
<p>This work was supported by the Centre for Computational Inference in Evolutionary Life Science (CELS). We also
acknowledge generous support by the Research Council of Norway for an IKTPLUSS project (#311341) to KR and
GKS.</p>
<p><strong>Affiliation</strong></p>
<p>KD, IG, MP and GK: Biomedical Informatics research group, Department of Informatics, University of Oslo, Oslo, Norway</p>
<p>KD, CK and GK: Centre for Bioinformatics, University of Oslo, Oslo, Norway,</p>
<p>MP, CK and GK: UiORealArt Convergence Environment, University of Oslo, Oslo, Norway</p>
<div class="docutils container" id="id19">
<dl class="citation">
<dt class="label" id="id38"><span class="brackets"><a class="fn-backref" href="#id3">1</a></span></dt>
<dd><p>Tiobe index. Jun 2022. URL: <a class="reference external" href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>.</p>
</dd>
<dt class="label" id="id33"><span class="brackets"><a class="fn-backref" href="#id4">2</a></span></dt>
<dd><p>Paszke, Adam and Gross, Sam and Massa, Francisco and Lerer, Adam and Bradbury, James and Chanan, Gregory and Killeen, Trevor and Lin, Zeming and Gimelshein, Natalia and Antiga, Luca and Desmaison, Alban and Kopf, Andreas and Yang, Edward and DeVito, Zachary and Raison, Martin and Tejani, Alykhan and Chilamkurthy, Sasank and Steiner, Benoit and Fang, Lu and Bai, Junjie and Chintala, Soumith. PyTorch: An Imperative Style, High-Performance Deep Learning Library. 2019. URL: <a class="reference external" href="http://papers.neurips.cc/paper/9015-pytorch-an-imperative-style-high-performance-deep-learning-library.pdf">http://papers.neurips.cc/paper/9015-pytorch-an-imperative-style-high-performance-deep-learning-library.pdf</a>.</p>
</dd>
<dt class="label" id="id34"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>Ryan Abernathey and Kevin Paul and Joe Hamman and Matthew Rocklin and Chiara Lepore and Michael Tippett and Naomi Henderson and Richard Seager and Ryan May and Davide Del Vento. Pangeo NSF Earthcube Proposal. 8 2017. URL: <a class="reference external" href="https://figshare.com/articles/Pangeo_NSF_Earthcube_Proposal/5361094">https://figshare.com/articles/Pangeo_NSF_Earthcube_Proposal/5361094</a>, <a class="reference external" href="https://doi.org/10.6084/m9.figshare.5361094.v1">doi:10.6084/m9.figshare.5361094.v1</a>.</p>
</dd>
<dt class="label" id="id35"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>Martin Raspaud and David Hoese and Panu Lahtinen and Gerrit Holl and Stephan Finkensieper and Simon Proud and Adam Dybbroe and Andrea Meraner and Joleen Feltz and Xin Zhang and strandgren and Sauli Joro and William Roberts and BENR0 and Lars Orum Rasmussen and mherbertson and Jorge Humberto Bravo MÃ©ndez and Yufei Zhu and rdaruwala and Pierre de Buyl and Tommy Jasmin and BengtRydberg and Christian Kliche and Talfan Barnie and Eysteinn SigurÃ°sson and Sebastian Brodehl and R.K.Garcia and Thomas Leppelt and Taiga Tsukada. Pytroll/satpy: version 0.38.0 (2022/11/11). November 2022. URL: <a class="reference external" href="https://doi.org/10.5281/zenodo.7313596">https://doi.org/10.5281/zenodo.7313596</a>, <a class="reference external" href="https://doi.org/10.5281/zenodo.7313596">doi:10.5281/zenodo.7313596</a>.</p>
</dd>
<dt class="label" id="id36"><span class="brackets"><a class="fn-backref" href="#id4">5</a></span></dt>
<dd><p>Robitaille, Thomas P and Tollerud, Erik J and Greenfield, Perry and Droettboom, Michael and Bray, Erik and Aldcroft, Tom and Davis, Matt and Ginsburg, Adam and Price-Whelan, Adrian M and Kerzendorf, Wolfgang E and others. Astropy: a community python package for astronomy. <em>Astronomy &amp; Astrophysics</em>, 558:A33, 2013.</p>
</dd>
<dt class="label" id="id37"><span class="brackets">6</span><span class="fn-backref">(<a href="#id5">1</a>,<a href="#id12">2</a>)</span></dt>
<dd><p>Harris, Charles R and Millman, K Jarrod and Van Der Walt, Stéfan J and Gommers, Ralf and Virtanen, Pauli and Cournapeau, David and Wieser, Eric and Taylor, Julian and Berg, Sebastian and Smith, Nathaniel J and others. Array programming with NumPy. <em>Nature</em>, 585(7825):357–362, 2020.</p>
</dd>
<dt class="label" id="id40"><span class="brackets"><a class="fn-backref" href="#id6">7</a></span></dt>
<dd><p>Cock, Peter JA and Antao, Tiago and Chang, Jeffrey T and Chapman, Brad A and Cox, Cymon J and Dalke, Andrew and Friedberg, Iddo and Hamelryck, Thomas and Kauff, Frank and Wilczynski, Bartek and others. Biopython: freely available Python tools for computational molecular biology and bioinformatics. <em>Bioinformatics</em>, 25(11):1422–1423, 2009.</p>
</dd>
<dt class="label" id="id39"><span class="brackets"><a class="fn-backref" href="#id7">8</a></span></dt>
<dd><p>Kunzmann, Patrick and Hamacher, Kay. Biotite: a unifying open source computational biology framework in Python. <em>BMC bioinformatics</em>, 19(1):1–8, 2018.</p>
</dd>
<dt class="label" id="id32"><span class="brackets">9</span><span class="fn-backref">(<a href="#id8">1</a>,<a href="#id18">2</a>)</span></dt>
<dd><p>Quinlan, Aaron R and Hall, Ira M. BEDTools: a flexible suite of utilities for comparing genomic features. <em>Bioinformatics</em>, 26(6):841–842, 2010.</p>
</dd>
<dt class="label" id="id31"><span class="brackets"><a class="fn-backref" href="#id9">10</a></span></dt>
<dd><p>Marcais, G and Kingsford, C. Jellyfish: A fast k-mer counter. <em>Tutorialis e Manuais</em>, 1:1–8, 2012.</p>
</dd>
<dt class="label" id="id30"><span class="brackets">11</span><span class="fn-backref">(<a href="#id10">1</a>,<a href="#id15">2</a>,<a href="#id18">3</a>)</span></dt>
<dd><p>Danecek, Petr and Bonfield, James K and Liddle, Jennifer and Marshall, John and Ohan, Valeriu and Pollard, Martin O and Whitwham, Andrew and Keane, Thomas and McCarthy, Shane A and Davies, Robert M and others. Twelve years of SAMtools and BCFtools. <em>Gigascience</em>, 10(2):giab008, 2021.</p>
</dd>
<dt class="label" id="id25"><span class="brackets">12</span><span class="fn-backref">(<a href="#id11">1</a>,<a href="#id17">2</a>)</span></dt>
<dd><p>Fornes, Oriol and Castro-Mondragon, Jaime A and Khan, Aziz and Van der Lee, Robin and Zhang, Xi and Richmond, Phillip A and Modi, Bhavi P and Correard, Solenne and Gheorghe, Marius and Baranašić, Damir and others. JASPAR 2020: update of the open-access database of transcription factor binding profiles. <em>Nucleic Acids Research</em>, 48(D1):D87–D92, 2020.</p>
</dd>
<dt class="label" id="id29"><span class="brackets"><a class="fn-backref" href="#id13">13</a></span></dt>
<dd><p>Forsgren, Nicole and Smith, Dustin and Humble, Jez and Frazelle, Jessie. 2019 Accelerate state of devops report. 2019.</p>
</dd>
<dt class="label" id="id27"><span class="brackets"><a class="fn-backref" href="#id14">14</a></span></dt>
<dd><p>MacIver, David R and Hatfield-Dodds, Zac and others. Hypothesis: a new approach to property-based testing. <em>Journal of Open Source Software</em>, 4(43):1891, 2019.</p>
</dd>
<dt class="label" id="id24"><span class="brackets"><a class="fn-backref" href="#id16">15</a></span></dt>
<dd><p>de Souza, Natalie. The ENCODE project. <em>Nature Methods</em>, 9(11):1046–1046, 2012.</p>
</dd>
</dl>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../developer_guide/encodings.html" class="btn btn-neutral float-left" title="Implementing encodings" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Knut Rand.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>